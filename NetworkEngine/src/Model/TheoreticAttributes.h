/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

/*
 * TheoreticAttributes.h
 *
 *  Created on: Oct 5, 2009
 *      Author: Catalin Pop
 */

#ifndef THEORETICATTRIBUTES_H_
#define THEORETICATTRIBUTES_H_
#include <boost/noncopyable.hpp>
#include <map>
#include <list>
#include <stack>
#include "Common/NETypes.h"
#include "Misc/Math/Compute.h"
#include <boost/unordered_set.hpp>
#include "modelDefault.h"
#include "model.h"

namespace NE {

namespace Model {

#define ALL_SLOTS_OCCUPIED  0x3FFFFFFF

struct MngChunk {
    Address16   owner;
    MngChunk():owner(0) {};
};

struct BandwidthChunck {
    Uint8   setNo;
    Uint8   freqNo;
    Uint32  slotsReservationMap;
    bool usedForRouter;

    BandwidthChunck();

    BandwidthChunck(Uint8 setNo_, Uint8 freqNo_);

    Uint16 getFirstAvailableSlot();

    void reserveSlot(Uint16 offset)  { slotsReservationMap |=  (1 << offset); }
    void unreserveSlot(Uint16 offset) { slotsReservationMap &=  ~(1 << offset); }
    bool isEmpty() { return slotsReservationMap ==  0; }

    friend std::ostream& operator<<(std::ostream& stream, const BandwidthChunck& bandwidthChunck);
};
typedef std::list<BandwidthChunck> BCList;

inline
std::ostream& operator<<(std::ostream& stream, const BCList& bcList) {
    for(BCList::const_iterator it = bcList.begin(); it != bcList.end(); ++it) {
        stream << "{" << *it << "}, ";
    }
    return stream;
}


/**
 * An Uint32 that is formated as : Address16_ContractID.
 * It contains address16 of the owner of the contract with id ContractID
 */
typedef Uint32 ServedContractKey;


/**
 * Map to hold all contracts that traverse(are served by) the current device.
 * Key: ServedContractKey(Address16_ContractID)
 * Value: Uint16 - payload generated buy this contract. Payload is as number of slots / superframe used by this contract
 */
typedef std::map<EntityIndex, float> ServedContractsMap;

/**
 * Map to hold the association Link to Contract , to be used by App Link Allocation for de dealocation/termination of a contract.
 * This map is used to find the contract that uses the current APP link.
 * Key: EntityIndex - Link index of current device
 * Value: EntityIndex - Contract index of the contract that use this link. This contract may be of any device in the network.
 */
typedef std::map<EntityIndex, EntityIndex> LinkToContractMap;

/**
 * List of EntityIndex of links.
 */
typedef std::list<EntityIndex> LinksList;

/**
 * Map to hold the list of links used by a contract.
 * Key: EntityIndex of Contract
 * Value: LinksList of links used by a contract.
 */
typedef std::map<EntityIndex, LinksList> ContractToLinksMap;

struct BadTrasferRateDevice {
    Address16 device16;
    Uint32 timeIgnoreStared;

    BadTrasferRateDevice(Address16 _device16):
        device16(_device16),
        timeIgnoreStared(time(NULL)) {
    }

    bool operator==(const BadTrasferRateDevice &badDevice) const {
        return (badDevice.device16 == device16);
    }

};

typedef std::list<BadTrasferRateDevice> BadRateDevicesList;
typedef std::set<Address64> Address64Set;


struct TheoreticAttributes: public boost::noncopyable {
    BCList  mngChunckInboundNonRouter;
    BCList  mngChunckInboundRouter;
    BCList  mngChunckOutbound;
    Address16 candidates[DEFAULT_MAX_NO_CANDIDATES];

    Uint16 childID;
    /**
     * Add/Acummulate the traffic generated by a contract that traverse this device. This trafic is used by the App Link Allocation algorithm
     * for the allocation of retry and backup application trafic.
     */
    ServedContractsMap servedContracts;

    /**
     * Map to hold the association Link to Contract , to be used by App Link Allocation for de dealocation/termination of a contract.
     * This map is used to find the contract that uses the current APP link.
     */
    LinkToContractMap linkToContract;

    /**
     * Map to hold the list of links used by a contract.
     */
    ContractToLinksMap contractLinks;

    /**
     * Map to hold the list of links used by a UDO contract.
     */
    ContractToLinksMap udoContract2Links;

    /**
     * Map to hold the association Link to UDO Contract, to be used by Mng Link Allocation for dealocation/termination of a contract.
     * This map is used to find the contract that uses the current APP link.
     */
    LinkToContractMap link2UdoContract;

    BadRateDevicesList devicesToIgnore;

    /**
     * in order to make only one modification on a device at the graph evaluation...if isSelectedAsBackup = true; will not allow other new backup
     */
    bool isSelectedAsBackup;

    /**
     * Contains the list of children.
     */
    std::set<Address64> children;

    TheoreticAttributes() {
        memset(candidates, 0, sizeof(candidates));
        childID = 0;
        isSelectedAsBackup=false;

    }

    /**
     * Add/Acummulate the traffic generated by a contract that traverse this device. This trafic is used by the App Link Allocation algorithm
     * for the allocation of retry and backup application trafic.
     * @param contractKey
     * @param payload
     */
    void addServedContract(EntityIndex contractKey, float traffic);

    void removeServedContract(EntityIndex contractKey);

    float getServedContractsTraffic();

    void removeChunckInboundRouter(Uint8 bcSetNo, Uint8 bcFreqNo);

    void removeChunckInboundNonRouter(Uint8 bcSetNo, Uint8 bcFreqNo);

    void deleteCandidate(Address16 candidate);

    void deleteCandidateFromPosition(Uint8 position);


    void clearCandidates();

    bool isCandidateOnList(Address16 candidate);

    void addLinkIndexForContract(EntityIndex contractIndex, EntityIndex linkIndex){
        contractLinks[contractIndex].push_back(linkIndex);//is used with [] because if not already exist (pair contract-linkslist) will be created
    }

    bool candidateIsBadRate(Address16 candidate);

    void addBadRateCandidate(Address16 candidate) {
        BadTrasferRateDevice device(candidate);
        devicesToIgnore.push_back( device );
    }

    void setContractIndexForLink(EntityIndex linkIndex, EntityIndex contractIndex){
        linkToContract[linkIndex]=contractIndex;//is used with [] because if not already exist (pair link-contract) will be created
    }

    void getServedContracts(EntityIndexList& servedContractsList);

    void getLinksForContract(EntityIndex& contract, EntityIndexList& linksList);

    Uint16 getNoOfUdoContractsAtOneSecond();

    friend std::ostream& operator<<(std::ostream& stream, const TheoreticAttributes& theoreticAttributes);
};

} // namespace Model

} // namespace NE

#endif /* THEORETICATTRIBUTES_H_ */
