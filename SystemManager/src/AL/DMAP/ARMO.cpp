/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

/**
 * @author beniamin.tecar, sorin.bidian
 */
#include "ARMO.h"

#include "ASL/PDUUtils.h"
#include "Common/AttributesIDs.h"
#include "Common/SmSettingsLogic.h"
#include "Common/MethodsIDs.h"
#include "Common/HandleFactory.h"
#include "Misc/Convert/Convert.h"
#include "Model/EngineProvider.h"
#include "Stats/Isa100SMStateLog.h"
#include "Model/Operations/smApplicationAlertTypes.h"
#include "Common/HandleFactory.h"
#include "Common/ClockSource.h"
#include "Misc/Marshall/NetworkOrderStream.h"
#include "Misc/Convert/Convert.h"
#include "AL/Types/AlertTypes.h"

using namespace Isa100::ASL;
using namespace Isa100::ASL::Services;
using namespace Isa100::Common::Objects;
using namespace Isa100::Model;
using namespace NE::Model;
using namespace NE::Common;
using namespace NE::Model::Operations;
using namespace NE::Misc::Marshall;
using namespace NE::Misc::Convert;

namespace Isa100 {
namespace AL {
namespace SMAP {

ARMO::ARMO(Isa100::Common::TSAP::TSAP_Enum tsap, NE::Model::IEngine* engine_) :
    Isa100Object(tsap, engine_) {
    std::string objectIdString;
    getObjectIDString(objectIdString);
    LOG_INFO(LOG_OI << "LIFE: created object:" << objectIdString);

    engine->registerAlertSender(this);

    lastAlertTime = ClockSource::getCurrentTime();
}

ARMO::~ARMO() {
    std::string objectIdString;
    getObjectIDString(objectIdString);
    LOG_INFO(LOG_OI << "LIFE: destroyed object:" << objectIdString);
}

void ARMO::indicate(Isa100::ASL::Services::ASL_AlertAcknowledge_IndicationPointer indication) {
    //receive acks
}

void ARMO::execute(Uint32 currentTime) {
    resetLifeTime(currentTime); //resets the timeout alarm. This object has forever life time.

    //dispatch alerts
    Device *gw = engine->getSubnetsContainer().getGateway();
    if (!gw) {
        LOG_DEBUG("GW not joined");
        return;
    }

    if ((gw->statusForReports == StatusForReports::SEC_CONFIRM_RESPONSE_SENT || gw->statusForReports
                == StatusForReports::JOINED_AND_CONFIGURED) && currentTime >= lastAlertTime
                + SmSettingsLogic::instance().joinLeaveAlertPeriod) {

        if (alertList.empty()) {
            return;
        }

        std::vector<AlertOperationPointer> sameTypeAlertsChunk;

        std::vector<AlertOperationPointer>::iterator itAlerts = alertList.begin();
        int alertType = (*itAlerts)->getAlertType();
        sameTypeAlertsChunk.push_back(*itAlerts);

        //LOG_INFO("[SORIN] alertList size=" << (int) alertList.size());
        //LOG_INFO("[SORIN]       alert with type " << (*itAlerts)->getAlertType());

        for (itAlerts = alertList.begin() + 1; itAlerts != alertList.end(); ++itAlerts) {

            //LOG_INFO("[SORIN]       alert with type " << (*itAlerts)->getAlertType());

            //dispatch chunks of alerts for which alertType is the same
            if (alertType != (*itAlerts)->getAlertType()) {

                //LOG_INFO("[SORIN] dispatch type " << alertType);
                dispatchAlert(sameTypeAlertsChunk, alertType);

                alertType = (*itAlerts)->getAlertType();
                sameTypeAlertsChunk.clear();
            }

            sameTypeAlertsChunk.push_back(*itAlerts);
        }

        //clear alert list
        alertList.clear();

        lastAlertTime = currentTime;

        //LOG_INFO("[SORIN] dispatch type " << alertType);
        dispatchAlert(sameTypeAlertsChunk, alertType);
    }
}

// implement IAlertSender
void ARMO::sendAlert(AlertOperationPointer& alertOperation) {
    if (!SmSettingsLogic::instance().enableAlertsGeneratedBySM) {
        LOG_INFO("Custom alerts generated by SM are disabled.");
        return;
    }

    int alertType = alertOperation->getAlertType();

    //LOG_INFO("[SORIN] got alert; type=" << alertType);
    LOG_INFO("got alert; type=" << alertType);

    if (alertType == SMAlertTypes::DeviceJoin || alertType == SMAlertTypes::DeviceJoinFailed || alertType
                == SMAlertTypes::DeviceLeave) {

        //avoid storing 2 consecutive alerts of type=DeviceJoinFailed for the same device
    	 std::vector<NE::Model::Operations::AlertOperationPointer>::reverse_iterator lastAlert ;
    	 lastAlert = alertList.rbegin();
        if (!alertList.empty() && alertType == SMAlertTypes::DeviceJoinFailed && (*lastAlert)->getAlertType()
                    == SMAlertTypes::DeviceJoinFailed) {

            AlertJoinFailed *lastAlertJoinFailed = (AlertJoinFailed*) alertOperation->getContent();
            AlertJoinFailed *newAlertJoinFailed = (AlertJoinFailed*) (*lastAlert)->getContent();
            if (lastAlertJoinFailed->deviceEUI64 == newAlertJoinFailed->deviceEUI64) {
                alertList.pop_back();
                LOG_INFO("erasing previous alert of type DeviceJoinFailed");
            }
        }

        alertList.push_back(alertOperation); //join/leave alerts are sent in chunks based on type

    } else if (alertType == SMAlertTypes::TransferStarted || alertType == SMAlertTypes::TransferProgress || alertType
                == SMAlertTypes::TransferEnded) {

        dispatchAlert(alertOperation);
    }
}

void ARMO::dispatchAlert(std::vector<AlertOperationPointer>& alertOperations, int alertType) {

    //alerts are dispatched to GW, receiving object ID = 12, UAP = 2
    Isa100::AL::ObjectID::ObjectIDEnum destinationObjectID = 12;
    const Isa100::Common::TSAP::TSAP_Enum destinationTSAP = TSAP::TSAP_UAP2;

    NE::Model::PhyContract * contract_SM_GW = engine->findManagerContractToDevice(
                engine->getSubnetsContainer().getGatewayAddress32(),//
                TSAP::TSAP_DMAP, destinationTSAP);

    if (!contract_SM_GW) {
        LOG_ERROR("Contract between SM and GW SMAP->UAP2 not found. Alert cannot be sent.");
        return;
    }

    AppHandle reqID = HandleFactory().CreateHandle();

    Isa100::ASL::PDU::ClientServerPDUPointer apdu(new Isa100::ASL::PDU::ClientServerPDU( //
                Isa100::Common::PrimitiveType::request, //
                Isa100::Common::ServiceType::alertReport, //
                ObjectID::ID_ARMO, //
                destinationObjectID, //
                reqID));

    NetworkOrderStream payloadStream;
    Uint8 alertTypeToSend = 0; //this is as specified in NivisObjects; differs from alertOperation.type which is an enum with all custom defined types
    Uint32 detectionTime = 0; //will be the detection tai of the last alert in the list

    Uint16 detectingObject;
    if (alertType == SMAlertTypes::DeviceJoin || alertType == SMAlertTypes::DeviceJoinFailed || alertType
                == SMAlertTypes::DeviceLeave) {

        detectingObject = (Uint16) ObjectID::ID_SMO;

        if (alertType == SMAlertTypes::DeviceJoin) {
            payloadStream.write((Uint16) alertOperations.size());
        }

    } else if (alertType == SMAlertTypes::TransferStarted || alertType == SMAlertTypes::TransferProgress || alertType
                == SMAlertTypes::TransferEnded) {

        detectingObject = (Uint16) ObjectID::ID_UDO1;

    } else {
        LOG_ERROR("unknown alert type: " << alertType);
        return;
    }

    std::set<Address64> insertedAddresses;

    for (std::vector<AlertOperationPointer>::iterator itOperation = alertOperations.begin(); itOperation
                != alertOperations.end(); ++itOperation) {

        AlertOperationPointer alertOperation = *itOperation;

        if (alertType != alertOperation->getAlertType()) {
            LOG_ERROR("Alert with type=" << alertOperation->getAlertType() << "present in chunk with type="
                        << alertType << "Aborting alert sending...");
            return;
        }

        switch (alertType) {
            case SMAlertTypes::DeviceJoin: {
                alertTypeToSend = 0;
                AlertJoin *alertJoin = (AlertJoin*) alertOperation->getContent();
                alertJoin->networkAddress.marshall(payloadStream);
                payloadStream.write(alertJoin->deviceType);
                alertJoin->deviceEUI64.marshall(payloadStream);
                payloadStream.write(alertJoin->powerSupplyStatus);
                payloadStream.write(alertJoin->joinStatus);

                Bytes manufacturer(alertJoin->manufacturer.begin(), alertJoin->manufacturer.end());
                payloadStream.write((Uint8) manufacturer.size());
                payloadStream.write(manufacturer);

                Bytes model(alertJoin->model.begin(), alertJoin->model.end());
                payloadStream.write((Uint8) model.size());
                payloadStream.write(model);

                Bytes revision(alertJoin->revision.begin(), alertJoin->revision.end());
                payloadStream.write((Uint8) revision.size());
                payloadStream.write(revision);

                Bytes deviceTag(alertJoin->deviceTag.begin(), alertJoin->deviceTag.end());
                payloadStream.write((Uint8) deviceTag.size());
                payloadStream.write(deviceTag);

                Bytes serialNo(alertJoin->serialNo.begin(), alertJoin->serialNo.end());
                payloadStream.write((Uint8) serialNo.size());
                payloadStream.write(serialNo);

                break;
            }
            case SMAlertTypes::DeviceJoinFailed: {
                alertTypeToSend = 1;
                AlertJoinFailed *alertJoinFailed = (AlertJoinFailed*) alertOperation->getContent();

                //skip adding payload if there's already one alert for this deviceEUI64
                if (insertedAddresses.find(alertJoinFailed->deviceEUI64) != insertedAddresses.end()) {
                    continue;
                }
                insertedAddresses.insert(alertJoinFailed->deviceEUI64);

                alertJoinFailed->deviceEUI64.marshall(payloadStream);
                payloadStream.write(alertJoinFailed->joinPhase);
                payloadStream.write(alertJoinFailed->failureReason);
                break;
            }
            case SMAlertTypes::DeviceLeave: {
                alertTypeToSend = 2;
                AlertLeave *alertLeave = (AlertLeave*) alertOperation->getContent();
                alertLeave->deviceEUI64.marshall(payloadStream);
                payloadStream.write(alertLeave->leaveReason);
                break;
            }
            case SMAlertTypes::TransferStarted: {
                alertTypeToSend = 0;
                AlertTransferStarted *alertTransferStarted = (AlertTransferStarted*) alertOperation->getContent();
                alertTransferStarted->deviceEUI64.marshall(payloadStream);
                payloadStream.write(alertTransferStarted->bytesPerPacket);
                payloadStream.write(alertTransferStarted->totalpackets);
                payloadStream.write(alertTransferStarted->totalBytes);
                break;
            }
            case SMAlertTypes::TransferProgress: {
                alertTypeToSend = 1;
                AlertTransferProgress *alertTransferProgress = (AlertTransferProgress*) alertOperation->getContent();
                for (std::vector<DeviceTransferProgress>::iterator itDevices =
                            alertTransferProgress->transferProgressList.begin(); itDevices
                            != alertTransferProgress->transferProgressList.end(); ++itDevices) {

                    itDevices->deviceEUI64.marshall(payloadStream);
                    payloadStream.write(itDevices->packetsTransferred);
                }
                break;
            }
            case SMAlertTypes::TransferEnded: {
                alertTypeToSend = 2;
                AlertTransferEnded *alertTransferEnded = (AlertTransferEnded*) alertOperation->getContent();
                alertTransferEnded->deviceEUI64.marshall(payloadStream);
                payloadStream.write(alertTransferEnded->errorCode);
                break;
            }

            default:
                LOG_ERROR("unknown alert type: " << alertType);
                return;
        }

        detectionTime = alertOperation->getDetectionTime();
    }

    BytesPointer alertValue(new Bytes(payloadStream.ostream.str()));
    TAINetworkTimeValue detectionTimePDU(detectionTime, 0);

    AlertReportPDUPointer alertReportPDU(new AlertReportPDU( //
                reqID % 255, // alertID - valid range: 0-255
                (Uint16) TSAP::TSAP_SMAP + 0xF0B0, detectingObject, //SMAP - SMO, UDO
                detectionTimePDU, //
                (Uint8) Isa100::AL::Types::AlertClass::event, (Uint8) 0, //alarmDirection
                (Uint8) Isa100::AL::Types::AlertCategory::process, (Uint8) 0, // ?? - alertPriority
                (Uint8) alertTypeToSend, //
                alertValue));

    ClientServerPDUPointer apduAlert = PDUUtils::appendAlertReport(apdu, alertReportPDU);

    ASL_AlertReport_RequestPointer primitiveRequest(new ASL_AlertReport_Request( //
                contract_SM_GW->contractID, //
                contract_SM_GW->destination32, //
                ServicePriority::high, //TODO: establish priority
                false, //discardEligible
                destinationTSAP, destinationObjectID, //
                TSAP::TSAP_DMAP, ObjectID::ID_ARMO, //
                apduAlert));

    LOG_INFO("Send alert: ID=" << (int) reqID % 255 << ", type=" << (int) alertTypeToSend << "(" << alertType << ")"
                << ", detectingObj=" << (int) detectingObject << ", value=" << bytes2string(*alertValue));

    messageDispatcher->Request(primitiveRequest);
}

void ARMO::dispatchAlert(NE::Model::Operations::AlertOperationPointer& alertOperation) {

    //alerts are dispatched to GW, receiving object ID = 12, UAP = 2
    Isa100::AL::ObjectID::ObjectIDEnum destinationObjectID = 12;
    const Isa100::Common::TSAP::TSAP_Enum destinationTSAP = TSAP::TSAP_UAP2;

    NE::Model::PhyContract * contract_SM_GW = engine->findManagerContractToDevice(
                engine->getSubnetsContainer().getGatewayAddress32(),//
                TSAP::TSAP_DMAP, destinationTSAP);

    if (!contract_SM_GW) {
        LOG_ERROR("Contract between SM and GW SMAP->UAP2 not found. Alert cannot be sent.");
        return;
    }

    AppHandle reqID = HandleFactory().CreateHandle();

    Isa100::ASL::PDU::ClientServerPDUPointer apdu(new Isa100::ASL::PDU::ClientServerPDU( //
                Isa100::Common::PrimitiveType::request, //
                Isa100::Common::ServiceType::alertReport, //
                ObjectID::ID_ARMO, //
                destinationObjectID, //
                reqID));

    NetworkOrderStream payloadStream;
    Uint8 alertTypeToSend; //this is as specified in NivisObjects; differs from alertOperation.type which is an enum with all custom defined types
    Uint16 detectingObject;

    switch (alertOperation->getAlertType()) {
        case SMAlertTypes::DeviceJoin: {
            alertTypeToSend = 0;
            detectingObject = (Uint16) ObjectID::ID_SMO;
            AlertJoin *alertJoin = (AlertJoin*) alertOperation->getContent();
            alertJoin->networkAddress.marshall(payloadStream);
            payloadStream.write(alertJoin->deviceType);
            alertJoin->deviceEUI64.marshall(payloadStream);
            payloadStream.write(alertJoin->powerSupplyStatus);
            payloadStream.write(alertJoin->joinStatus);

            Bytes manufacturer(alertJoin->manufacturer.begin(), alertJoin->manufacturer.end());
            payloadStream.write((Uint8) manufacturer.size());
            payloadStream.write(manufacturer);

            Bytes model(alertJoin->model.begin(), alertJoin->model.end());
            payloadStream.write((Uint8) model.size());
            payloadStream.write(model);

            Bytes revision(alertJoin->revision.begin(), alertJoin->revision.end());
            payloadStream.write((Uint8) revision.size());
            payloadStream.write(revision);

            Bytes deviceTag(alertJoin->deviceTag.begin(), alertJoin->deviceTag.end());
            payloadStream.write((Uint8) deviceTag.size());
            payloadStream.write(deviceTag);

            Bytes serialNo(alertJoin->serialNo.begin(), alertJoin->serialNo.end());
            payloadStream.write((Uint8) serialNo.size());
            payloadStream.write(serialNo);
            break;
        }
        case SMAlertTypes::DeviceJoinFailed: {
            alertTypeToSend = 1;
            detectingObject = (Uint16) ObjectID::ID_SMO;
            AlertJoinFailed *alertJoinFailed = (AlertJoinFailed*) alertOperation->getContent();
            alertJoinFailed->deviceEUI64.marshall(payloadStream);
            payloadStream.write(alertJoinFailed->joinPhase);
            payloadStream.write(alertJoinFailed->failureReason);
            break;
        }
        case SMAlertTypes::DeviceLeave: {
            alertTypeToSend = 2;
            detectingObject = (Uint16) ObjectID::ID_SMO;
            AlertLeave *alertLeave = (AlertLeave*) alertOperation->getContent();
            alertLeave->deviceEUI64.marshall(payloadStream);
            payloadStream.write(alertLeave->leaveReason);
            break;
        }
        case SMAlertTypes::TransferStarted: {
            alertTypeToSend = 0;
            detectingObject = (Uint16) ObjectID::ID_UDO1;
            AlertTransferStarted *alertTransferStarted = (AlertTransferStarted*) alertOperation->getContent();
            alertTransferStarted->deviceEUI64.marshall(payloadStream);
            payloadStream.write(alertTransferStarted->bytesPerPacket);
            payloadStream.write(alertTransferStarted->totalpackets);
            payloadStream.write(alertTransferStarted->totalBytes);
            break;
        }
        case SMAlertTypes::TransferProgress: {
            alertTypeToSend = 1;
            detectingObject = (Uint16) ObjectID::ID_UDO1;
            AlertTransferProgress *alertTransferProgress = (AlertTransferProgress*) alertOperation->getContent();
            for (std::vector<DeviceTransferProgress>::iterator itDevices =
                        alertTransferProgress->transferProgressList.begin(); itDevices
                        != alertTransferProgress->transferProgressList.end(); ++itDevices) {

                itDevices->deviceEUI64.marshall(payloadStream);
                payloadStream.write(itDevices->packetsTransferred);
            }
            break;
        }
        case SMAlertTypes::TransferEnded: {
            alertTypeToSend = 2;
            detectingObject = (Uint16) ObjectID::ID_UDO1;
            AlertTransferEnded *alertTransferEnded = (AlertTransferEnded*) alertOperation->getContent();
            alertTransferEnded->deviceEUI64.marshall(payloadStream);
            payloadStream.write(alertTransferEnded->errorCode);
            break;
        }

        default:
            LOG_ERROR("unknown alert type: " << alertOperation->getAlertType());
            return;
    }

    BytesPointer alertValue(new Bytes(payloadStream.ostream.str()));
    TAINetworkTimeValue detectionTime(alertOperation->getDetectionTime(), 0);

    AlertReportPDUPointer alertReportPDU(new AlertReportPDU( //
                reqID % 255, // alertID - valid range: 0-255
                (Uint16) TSAP::TSAP_SMAP + 0xF0B0, detectingObject, //
                detectionTime, //
                (Uint8) Isa100::AL::Types::AlertClass::event, (Uint8) 0, //alarmDirection
                (Uint8) Isa100::AL::Types::AlertCategory::process, (Uint8) 0, // ?? - alertPriority
                (Uint8) alertTypeToSend, //
                alertValue));

    ClientServerPDUPointer apduAlert = PDUUtils::appendAlertReport(apdu, alertReportPDU);

    ASL_AlertReport_RequestPointer primitiveRequest(new ASL_AlertReport_Request( //
                contract_SM_GW->contractID, //
                contract_SM_GW->destination32, //
                ServicePriority::high, //TODO: establish priority
                false, //discardEligible
                destinationTSAP, destinationObjectID, //
                TSAP::TSAP_DMAP, ObjectID::ID_ARMO, //
                apduAlert));

    LOG_INFO("Send alert: ID=" << (int) reqID % 255 << ", type=" << (int) alertTypeToSend << "("
                << alertOperation->getAlertType() << ")" << ", detectingObj=" << (int) detectingObject << ", value="
                << bytes2string(*alertValue));

    messageDispatcher->Request(primitiveRequest);

}

}
}
}

