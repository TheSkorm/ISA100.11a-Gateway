/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

/*
 * SecurityConfirmRequest.h
 *
 *  Created on: Mar 20, 2009
 *      Author: Andy
 */

#ifndef SECURITYCONFIRMREQUEST_H_
#define SECURITYCONFIRMREQUEST_H_

#include "Misc/Convert/Convert.h"
#include "Common/smTypes.h"
#include <iomanip>

using namespace NE::Misc::Convert;
using namespace NE::Misc::Marshall;

namespace Isa100 {
namespace Security {

struct SecurityConfirmRequest {

        /**
         * 128_Bit_Challenge_from_new_device is a fresh unique challenge generated by the new device to
         * verify that the security manager is alive.
         */
        Common::Uint128 bitChallengeResponseToSecurityManager; // 1


        void marshall(OutputStream& stream) {
            for (Uint8 i = 0; i < Common::CHALLENGE_BYTES_NO; i++) {
                stream.write(bitChallengeResponseToSecurityManager[i]);
            }
        }

        void unmarshall(InputStream& stream) {
            for (Uint8 i = 0; i < Common::CHALLENGE_BYTES_NO; i++) {
                stream.read(bitChallengeResponseToSecurityManager[i]);
            }
        }

        void toString( std::string &securityConfirmString) {
            std::ostringstream stream;
            stream << "SecurityConfirmRequest {bitChallengeResponseToSecurityManager=";

            for (Uint8 i = 0; i < Common::CHALLENGE_BYTES_NO; i++) {
                stream << std::uppercase << std::hex << std::setw(2) << std::setfill('0') << (int) bitChallengeResponseToSecurityManager[i];
                if (i % 2 == 1 && i != Common::CHALLENGE_BYTES_NO - 1) {
                    stream << ':';
                }
            }

            stream << "}";
            securityConfirmString = stream.str();
        }
};

}
}

#endif /* SECURITYCONFIRMREQUEST_H_ */
