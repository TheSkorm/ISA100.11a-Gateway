/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

////////////////////////////////////////////////////////////////////////////////
/// @file Service.h
/// @author Marcel Ionescu
/// @brief Generic service - interface
////////////////////////////////////////////////////////////////////////////////
#ifndef _SERVICE_H
#define _SERVICE_H

#include "../ISA100/porting.h"
#include "GSAP.h"

struct lease;
////////////////////////////////////////////////////////////////////////////////
/// @class CService
/// @brief Generic Service - base class for all service classes
/// @remarks
/// Usage: Create a map associating Interface Object Id with CService* containers
///		for all services (CInterfaceObjMgr).
///	Use SetInterfaceOID to register each service into list, and associate with
///		unique Interface Object Id (generated by CInterfaceObjMgr)
/// This will allow multiple instances of the same service, each with it's own
///		Interface Object Id
///
/// (USER -> GW) flow: Parse map<CService*> and call CanHandleServiceType to find
///		the service handling the service type. Once the CService* is found, call
///		CService::ProcessUserRequest to process the user request (resulting usually
///		in one call down ISA stack, but may result in zero or multiple stack calls
///
/// (ISA -> GW) flow: Parse map<CService*> and find the CService with destination
///		OID from GENERIC_ASL_SRVC Response. Call CService::ProcessAPDU or
///		CService::ProcessISATimeout dispatching by GENERIC_ASL_SRVC::m_ucType
///	Derived classes SHOULD override ProcessAPDU/ProcessISATimeout to do anything
////////////////////////////////////////////////////////////////////////////////
class CService{
public:

	inline CService( const char * p_szName )
		{ strncpy( m_szName, p_szName, sizeof(m_szName)-1 ); m_szName[ sizeof(m_szName) -1 ] = 0; };

	virtual ~CService( void ) {};
	
	/// Return true if the service is able to handle the service type received as parameter
	/// Used by (USER -> GW) flow
	virtual bool CanHandleServiceType( uint8 p_ucServiceType ) const = 0;

	/// (USER -> GW) Process a user request. Call from CInterfaceObjMgr::DispatchUserRequest
	/// p_pHdr members are converted to host order. Header and data CRC are verified.
	/// p_pData members are network order, must be converted by ProcessUserRequest
	virtual bool ProcessUserRequest( CGSAP::TGSAPHdr * p_pHdr, void * p_pData ) = 0;
	
	/// (ISA -> GW) Dispatch an ADPU. Call from CInterfaceObjMgr::DispatchAPDU
	virtual bool ProcessAPDU( uint16 p_unAppHandle, APDU_IDTF* p_pAPDUIdtf, GENERIC_ASL_SRVC* p_pRsp, GENERIC_ASL_SRVC* p_pReq );
	
	/// (ISA -> GW) Proces a ISA100 timeout. Call from CInterfaceObjMgr::DispatchISATimeout
	virtual bool ProcessISATimeout( uint16 p_unAppHandle, GENERIC_ASL_SRVC * p_pOriginalReq );

	/// Process a lease deletion: free resources, if necessary. Only some derived classess will implement
	/// Identified services using it: ClientServer service, BulkTransfer Service, PublishSubscribe service
	/// Default implementation does nothing
	inline virtual void OnLeaseDelete( lease* /*p_pLease*/ )	{ };

	///Set the interface object identifier. The id is taken from the Interface Object manager
	/// Used by (ISA -> GW) and (GW -> ISA) flow
	inline virtual void SetInterfaceOID( uint16 p_ushInterfaceOID ) { m_ushInterfaceOID = p_ushInterfaceOID; };

	/// (GW -> User) send an Indication provided as parameter to the user
	bool SendIndication( unsigned char p_ucServiceType, lease* p_pLease, uint8* p_pMsgData, uint32 p_dwMsgDataLen );

	/// Called on USR2: Dump status to LOG
	virtual void Dump( void );

	/// Return service name
	const char * Name( void ) { return m_szName; }

protected:

	uint16 m_ushInterfaceOID;	///< ObjectIdentifier The interfacce object identifier
	char m_szName[ 32 ];
};
///YGSAP status byte
enum YGS_Status{
	YGS_SUCCESS,	
	YGS_SUCCESS_REDUCED,
	YGS_SUCCESS_STALE,
	//		3, 4 reserved
	YGS_TAG_NOT_FOUND = 5,
	YGS_LIMIT_EXCEEDED,
	YGS_INVALID_TYPE,
	YGS_INVALID_TYPE_INFO,
	YGS_INVALID_SESSION,
	YGS_INVALID_MODE,
	YGS_INVALID_CATEGORY,
	YGS_INVALID_ALERT,
	YGS_NOT_ALLOWED,
	YGS_NOT_ACCESSIBLE,
	YGS_CACHE_MISS,
	YGS_COMM_FAILED,
	YGS_INVALID_LEASE,
	YGS_ABORTED,	//18
	YGS_FAILURE = 250 //250
};

#endif //_SERVICE_H
