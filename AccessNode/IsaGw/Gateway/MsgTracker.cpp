/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

////////////////////////////////////////////////////////////////////////////////
/// @file MsgTracker.cpp
/// @author 
/// @brief Gateway message tracker: associate application-provided message Handler[2]
///	@brief with SessionID[4]+TrackingID[4] which is used in GW-Host communication
////////////////////////////////////////////////////////////////////////////////
#include <string.h>
#include <arpa/inet.h>
#include "MsgTracker.h"
#include "../../Shared/Common.h"
#include "GwApp.h"

////////////////////////////////////////////////////////////////////////////////
/// @class CMsgTracker
/// @brief Message tracker, match ISA100 Stack requests/responses (identified by application handler)
/// @brief with host Session ID/Transaction ID. Track all the message exchanges in progress
////////////////////////////////////////////////////////////////////////////////
CMsgTracker::CMsgTracker()
: m_NrOfMessages(0)
, m_MaxAge( 5*60 )	///tracker should never expire a message before the stack does
{/// Max possible message lifetime is dynamic determined by traffic flow control. It may as well be greater than 5 minute (number of retries is set by the application)
}

CMsgTracker::~CMsgTracker()
{
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Add a new message to the tracker pool - identify by p_unAppHandle
/// @param p_unAppHandle - the request handle, used to find SessionID/TransactionID in tracker
/// @param p_nSession_ID	GS_Session_ID
/// @param p_TransactionID 	GS_Transaction_ID the 32-bit id generated by the host application
/// @param p_ServiceType Type of the host application message
/// @param p_pData pointer to a 16-byte buffer containing relevant information, or null if no other information is relevant
/// @return Number of tracked messages, or 0 if cannot add(buffer full)
/// @remarks Service type is necessary on error flow for services with more than one service type (SytemReports,Bulk)
////////////////////////////////////////////////////////////////////////////////
unsigned CMsgTracker::AddMessage( uint16 p_unAppHandle, unsigned p_nSessionID, uint32 p_TransactionID, uint8 p_ServiceType, const uint8* p_pData /*= NULL*/)
{
	if( m_NrOfMessages >= sizeof(m_MessageList)/sizeof(*m_MessageList) )
	{
		LOG("ERROR CMsgTracker::AddMessage(H %u S %u T %u): BUFFER FULL", p_unAppHandle, p_nSessionID, p_TransactionID );
		return 0;
	}
	m_MessageList[m_NrOfMessages].m_unAppHandle 	= p_unAppHandle;
	m_MessageList[m_NrOfMessages].m_nSessionID 		= p_nSessionID;
	m_MessageList[m_NrOfMessages].m_TransactionID 	= p_TransactionID;
	m_MessageList[m_NrOfMessages].m_ServiceType 	= p_ServiceType;
	m_MessageList[m_NrOfMessages].m_Time 			= time(NULL);
	m_MessageList[m_NrOfMessages].m_oCreat.MarkStartTime();
	if(p_pData){
		memcpy(m_MessageList[m_NrOfMessages].m_Data, p_pData, sizeof(m_MessageList[m_NrOfMessages].m_Data));
	}
	//LOG("CMsgTracker::AddMessage(H %u S %u T %u) %s Messages %u", p_unAppHandle, p_nSessionID, p_TransactionID, getGSAPServiceName(p_ServiceType), m_NrOfMessages+1);
	return ++m_NrOfMessages;
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Find a tracked message by p_unAppHandle
/// @param p_unAppHandle the request handle, used to find SessionID/TransactionID in tracker
/// @return a pointer to the MSG structure storing the data from the request
////////////////////////////////////////////////////////////////////////////////
MSG* CMsgTracker::FindMessage( uint16 p_unAppHandle, const char * p_szCallerName )
{
	unsigned i;
	for(i=0; i<m_NrOfMessages; ++i)
	{
		if (m_MessageList[i].m_unAppHandle == p_unAppHandle)
			break;
	}
	if(i>=m_NrOfMessages)
	{	/// PROGRAMMER ERROR: Tracker should never expire messages before stack. Stack should not overflow RequestID.
		LOG("ERROR %s(H %u): discarded by Tracker. This should not happen.", p_szCallerName, p_unAppHandle );
		return NULL;
	}
	return &m_MessageList[i];
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Remove a tracked message, searching by p_unAppHandle
/// @param p_unAppHandle the request handle, used to find SessionID/TransactionID in tracker
/// @remarks Called whenever a response comes from the field, after matching it to the original request
////////////////////////////////////////////////////////////////////////////////
void CMsgTracker::RemoveMessage( uint16 p_unAppHandle )
{
	unsigned i;
	for(i=0; i<m_NrOfMessages; ++i)
	{
		if( m_MessageList[i].m_unAppHandle == p_unAppHandle )
			break;
	}
	if(i>=m_NrOfMessages)
	{
		LOG("WARN CMsgTracker::RemoveMessage(H %u): not found (%u msg)", p_unAppHandle, m_NrOfMessages);
		return;
	}

	LOG("CMsgTracker::RemoveMessage(H %u) %s RTT: %.3f seconds", p_unAppHandle, getGSAPServiceName(m_MessageList[i].m_ServiceType), m_MessageList[i].m_oCreat.GetElapsedSec() );
	if(i<--m_NrOfMessages)
	{
		memmove(m_MessageList+i,m_MessageList+i+1,(m_NrOfMessages-i)*sizeof(MSG));
	}
}

////////////////////////////////////////////////////////////////////////////////
/// @author Marcel Ionescu
/// @brief Remove a message from tracker finding it by SessionID/TransactionID
/// @param p_nSessionID
/// @param p_dwTransactionID	
/// @remarks Called whenever a response comes from the field, after matching it to the original request
////////////////////////////////////////////////////////////////////////////////
void CMsgTracker::RemoveMessage( unsigned p_nSessionID, uint32 p_dwTransactionID )
{
	unsigned i;
	for(i=0; i<m_NrOfMessages; ++i)
	{
		if(	(m_MessageList[i].m_nSessionID    == p_nSessionID)
		&&	(m_MessageList[i].m_TransactionID == p_dwTransactionID) )
			break;
	}
	if(i>=m_NrOfMessages)
	{
		LOG("WARN CMsgTracker::RemoveMessage(S %u T %u): not found (%u msg)", p_nSessionID,  p_dwTransactionID, m_NrOfMessages);
		return;
	}

	LOG("CMsgTracker::RemoveMessage(S %u T %u) %s RTT: %.3f seconds", p_nSessionID, p_dwTransactionID, getGSAPServiceName(m_MessageList[i].m_ServiceType),m_MessageList[i].m_oCreat.GetElapsedSec() );
	if(i<--m_NrOfMessages)
	{
		memmove(m_MessageList+i,m_MessageList+i+1,(m_NrOfMessages-i)*sizeof(MSG));
	}
}


////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Renew a tracked message - associate with a new RequestID, refresh expire time
/// @param p_pMsg	pointer to the message
/// @param p_unAppHandle the new request handle
/// @return Number of tracked messages, or 0 if cannot find the message
/// @remarks Called on Topology/Bulk requests and any other client requests which
/// generate more than one message exchange with the SM/devices.
/// It is necessary because:
///		1 p_unAppHandle changes with each request, we must be able to use last p_unAppHandle
///			instead of first p_unAppHandle to match the session/transaction pair (see below)
///		2 The request might take more time than usual to complete, because there are several messages
///
/// @note p_unAppHandle should NOT be parameter, but shared between multiple messages semantically related
/// @note We are still keeping it because the stack does not delete a message imediately after a response is received
/// @note so we are forced to allocate a new p_unAppHandle for each request in a chain
////////////////////////////////////////////////////////////////////////////////
unsigned CMsgTracker::RenewMessage( MSG* p_pMsg, uint16 p_unAppHandle )
{
	p_pMsg->m_unAppHandle = p_unAppHandle;/// do not take out of tracking even on buffer full
	if( m_NrOfMessages >= sizeof(m_MessageList)/sizeof(*m_MessageList) )
	{
		LOG("WARNING CMsgTracker::RenewMessage(H %u S %u T %u): BUFFER FULL renew was partial", p_unAppHandle, p_pMsg->m_nSessionID, p_pMsg->m_TransactionID );
		return 0;
	}

	time_t tNow = time( NULL );
//	LOG( "RenewMessage: %s(H %u->%u) time %u", getGSAPServiceName(p_pMsg->m_ServiceType), p_pMsg->m_unAppHandle, p_unAppHandle, tNow - p_pMsg->m_Time );
	p_pMsg->m_Time =tNow;
	if(p_pMsg < m_MessageList+m_NrOfMessages-1)
	{
		m_MessageList[m_NrOfMessages]= *p_pMsg;
		memmove(p_pMsg, p_pMsg+1,(m_MessageList+m_NrOfMessages-p_pMsg)*sizeof(MSG));
	}
	return m_NrOfMessages;
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Renew a tracked message - associate with a new RequestID, refresh expire time
/// @param p_nSessionID
/// @param p_dwTransactionID
/// @param p_unAppHandle the new request handle
/// @return Number of tracked messages, or 0 if cannot find the message
/// @remarks Called on Topology/Bulk requests and any other client requests which
/// generate more than one message exchange with the SM/devices.
/// It is necessary because:
///		1 p_unAppHandle changes with each request, we must be able to use last p_unAppHandle
///			instead of first p_unAppHandle to match the session/transaction pair (see below)
///		2 The request might take more time than usual to complete, because there are several messages
///
/// @note p_unAppHandle should NOT be parameter, but shared between multiple messages semantically related
/// @note We are still keeping it because the stack does not delete a message imediately after a response is received
/// @note so we are forced to allocate a new p_unAppHandle for each request in a chain
////////////////////////////////////////////////////////////////////////////////
//void CMsgTracker::RenewMessage( unsigned p_nSessionID, uint32 p_dwTransactionID, uint16 p_unAppHandle)
unsigned CMsgTracker::RenewMessage( uint16 p_unAppHandleOld, uint16 p_unAppHandleNew )
{
	MSG * pMSG = FindMessage( p_unAppHandleOld, "RenewMessage" );
	if( !pMSG )
	{	/// PROGRAMMER ERROR 
		LOG("ERROR CMsgTracker::RenewMessage(H %u->%u) old AppH not found", p_unAppHandleOld, p_unAppHandleNew );
		return 0;	/// this does not happen - hopefully
	}
	return RenewMessage( pMSG, p_unAppHandleNew );
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Remove old messages (unlikely to get responses)
/// @remarks Some messages never get responses so they must be dropped every once in a while,
/// for instance every second, using this method
/// There is no need to send a CONFIRM(timeout) to host for expired messages.
///	The stack guarantees to generate timeout notification, CONFIRM's will be sent then
/// @note Maybe expiration should be done on Find() which parse the list anyway
////////////////////////////////////////////////////////////////////////////////
void CMsgTracker::DropExpired( void )
{
	unsigned i,j;
	time_t tNow = time(NULL);
	time_t tExpired = tNow - m_MaxAge;

	for(i=0; i<m_NrOfMessages; ++i)
	{	/// The list is time ordered. Stop at first valid message
		if(m_MessageList[i].m_Time >= tExpired ) /// First message not expired: valid
		{
			break;
		}
	}
	if(!i)
	{	/// None expired
		return;
	}
	
	LOG("WARN CMsgTracker::DropExpired: deleting %u out of %u messages", i, m_NrOfMessages );
	for(j=0; j<i; ++j)
	{	
		LOG("WARN CMsgTracker::DropExpired: (H %u S %u T %u) RTT: %.3f seconds",
			m_MessageList[j].m_unAppHandle, m_MessageList[j].m_nSessionID, m_MessageList[j].m_TransactionID, m_MessageList[j].m_oCreat.GetElapsedSec()  );
	}
	if( (m_NrOfMessages -= i) )
	{	/// Some messages remaining
		memmove( m_MessageList, m_MessageList+i, m_NrOfMessages*sizeof(MSG) );
	}
}

////////////////////////////////////////////////////////////////////////////////
/// @author - modified by Marcel Ionescu
/// @brief Dump tracker status to log
/// @remarks Some messages never get responses so they must be dropped every once in a while,
/// for instance every second, using this method
/// There is no need to send a CONFIRM(timeout) to host for expired messages.
///	The stack guarantees to generate timeout notification, CONFIRM's will be sent then
////////////////////////////////////////////////////////////////////////////////
void CMsgTracker::Dump( void )
{
	unsigned i;
	time_t tNow = time(NULL);

	LOG("CMsgTracker(%u messages):", m_NrOfMessages);
	for(i=0; i<m_NrOfMessages; ++i)
	{
		LOG(" MsgTracker (H %u S %u T %u) %s life %u seconds", m_MessageList[i].m_unAppHandle,
			m_MessageList[i].m_nSessionID, m_MessageList[i].m_TransactionID,
			getGSAPServiceName(m_MessageList[i].m_ServiceType), tNow - m_MessageList[i].m_Time );
	}
}

////////////////////////////////////////////////////////////////////////////////
/// @author Marcel Ionescu
/// @brief Process session delete (expire or explicit delete) - deleting associated resources
/// @remarks Delete all entries associated with p_nSessionID
/// TAKE CARE: Current implementation is highly inefficient
////////////////////////////////////////////////////////////////////////////////
void CMsgTracker::ProcessSessionDelete( unsigned p_nSessionID )
{
	LOG("CMsgTracker::ProcessSessionDelete(%u): search in %u items", p_nSessionID, m_NrOfMessages );
	while( true )
	{
		unsigned i;
		for(i=0; i<m_NrOfMessages; ++i)
		{
			if( m_MessageList[i].m_nSessionID == p_nSessionID )
				break;
		}
		if(i>=m_NrOfMessages)
		{	/// Done
			return;
		}

		LOG("CMsgTracker::ProcessSessionDelete(H %u S %u T %u) %s RTT: %.3f seconds",
			m_MessageList[i].m_unAppHandle, p_nSessionID, m_MessageList[i].m_TransactionID,
			getGSAPServiceName(m_MessageList[i].m_ServiceType), m_MessageList[i].m_oCreat.GetElapsedSec());
		if(i<--m_NrOfMessages)
		{
			memmove( m_MessageList+i, m_MessageList+i+1, (m_NrOfMessages-i)*sizeof(MSG));
		}
	}
}

