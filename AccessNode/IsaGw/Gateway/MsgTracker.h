/*
* Copyright (C) 2013 Nivis LLC.
* Email:   opensource@nivis.com
* Website: http://www.nivis.com
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3 of the License.
* 
* Redistribution and use in source and binary forms must retain this
* copyright notice.

* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

////////////////////////////////////////////////////////////////////////////////
/// @file MsgTracker.h
/// @author  modified by Marcel Ionescu
/// @brief Gateway message tracker: associate application-provided message Handler[2]
///	@brief with SessionID[4]+TrackingID[4] which is used in GW-Host communication
/// @todo
/// @todo In Release 1:
/// @todo 1. Use std:::list (must allow fast search/erase starting from both ends) instead of array
/// @todo
/// @todo 2. Search when a response is received should be done starting from the end,
/// @todo because the list is time ordered and is likely to receive responses in 
/// @todo almost the same order the req were sent (depending on the level, latency etc, 
/// @todo but this cannot be taken into account)
/// @todo
/// @todo 3. Measeure search performance - number of iterations / total number of elements, 
/// @todo to help improve the algorithm
/// @todo
/// @todo 4. Tracker time measurements should use ms, not seconds. Report message lifetime.
/// @todo
/// @todo
////////////////////////////////////////////////////////////////////////////////
#ifndef MSGTRACKER_H
#define MSGTRACKER_H

#include <time.h>

#include "../ISA100/typedef.h"
#include "../ISA100/config.h"
#include "../../Shared/MicroSec.h"

#define PROCESS_QUEUE_SIZE 100

////////////////////////////////////////////////////////////////////////////////
/// @struct MSG
/// @brief Match p_unAppHandle (used on ISA100 stack) with m_nSessionID+m_TrackingID (used by GSAP's)
////////////////////////////////////////////////////////////////////////////////
typedef struct{

	uint16	m_unAppHandle;	///< the mesasge identifier, provided by application and used by the stack
	
	unsigned m_nSessionID;	///< GS_Session_ID
	uint32 m_TransactionID;	///< GS_Transaction_ID generated by the host app, needed by the host app to match it with the response
	uint8	m_ServiceType;	///< Type of the host application message - necessary on error flow for services with more than one service type (SytemReports,Bulk)
	uint8	m_Data[16];		///< TODO: TBD if this is still used (any relevant data - currently used for the IPv6 address from contract requests)
	time_t	m_Time;			///< the UTC time when the request has been received from the host app, used for expiration purposes
	CMicroSec m_oCreat;		///< Creation time, used for RTT computing
}MSG;

////////////////////////////////////////////////////////////////////////////////
/// @class CMsgTracker
/// @brief Message tracker, match ISA100 Stack requests/responses (identified by application handler)
/// @brief with host Session ID/Transaction ID. Track all the message exchanges in progress
/// @remarks
////////////////////////////////////////////////////////////////////////////////
class CMsgTracker{
	/// [Marcel] TODO
	/// [Marcel] TODO: the current approach take a severe penalty on high number of pending requests. Must re-write
	/// [Marcel] TODO
	MSG			m_MessageList[2*PROCESS_QUEUE_SIZE];	///< chronologically sorted array of unanswered messages
	unsigned	m_NrOfMessages;			///< number of array elements in use
	int			m_MaxAge;				///< time to keep messages here, in seconds
public:
	CMsgTracker();
	~CMsgTracker();
	/// Add a new message to the tracker pool. Return number of tracked messages, or 0 if cannot add(buffer full)
	unsigned AddMessage( uint16 p_unAppHandle, unsigned p_nSessionID, uint32 p_TransactionID, uint8 p_ServiceType, const uint8* p_pData = NULL);

	/// Find a tracked message by p_unAppHandle
	MSG* FindMessage( uint16 p_unAppHandle, const char * p_szCallerName );

	/// Remove a tracked message, searching by p_unAppHandle
	void RemoveMessage( uint16 p_unAppHandle );

	/// remove a tracked message, finding it by SessionID/TransactionID
	void RemoveMessage( unsigned p_nSessionID, uint32 p_dwTransactionID );

	/// Renew a tracked message - associate with a new p_unAppHandle, refresh expire time
	/// p_unAppHandle should NOT be parameter, but shared between multiple messages semantically related
	/// We are still keeping it because the stack does not delete a message imediattely after a response is received
	unsigned RenewMessage( MSG* p_pMsg, uint16 p_unAppHandle );

	/// Renew a tracked message - associate with a new RequestID, refresh expire time
	/// p_unAppHandle should NOT be parameter, but shared between multiple messages semantically related
	/// We are still keeping it because the stack does not delete a message imediattely after a response is received
	//void RenewMessage( unsigned p_nSessionID, uint32 p_dwTransactionID, uint16 p_unAppHandle);
	unsigned RenewMessage( uint16 p_unAppHandleOld, uint16 p_unAppHandleNew);

	/// Remove old messages (unlikely to get responses)
	void DropExpired( void );

	/// Dump tracker status to log
	void Dump( void );
	
	/// Process session delete (expire or explicit delete) - deleting all entries associated with it
	void ProcessSessionDelete( unsigned  p_nSessionID );

};

#endif
